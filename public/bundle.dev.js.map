{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "browser.js",
    "index.js",
    "lib/board.js",
    "lib/canvas.js",
    "lib/food.js",
    "lib/game.js",
    "lib/snake.js",
    "lib/snake_segment.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "(() => {\n    'use strict'\n\n    console.log('Game is available through window.Game.')\n\n    // export game as global object\n    window.Game = require('./index.js')\n})()",
    "'use strict'\n\nconst Game = require('./lib/game.js')\n\nmodule.exports = Game",
    "const isNumberValid = (number) => (\n    typeof(number) === 'number' && number > 0\n)\n\nclass Board {\n    constructor(rows, lines) {\n        this.rows = parseInt(rows)\n        this.lines = parseInt(lines)\n\n        if(!isNumberValid(this.rows))  { throw new TypeError('`rows` must be a positive number greather than 0')}\n        if(!isNumberValid(this.lines)) { throw new TypeError('`lines` must be a positive number greather than 0')}\n    }\n\n    get maxRows() {\n        return this.rows\n    }\n\n    get maxLines() {\n        return this.lines\n    }\n}\n\nmodule.exports = Board\n",
    "const Food = require('./food')\n\nconst TILE_BACKGROUND_COLOR = 'white'\nconst RANDOM_FOOD_COLORS = ['red', 'blue', 'purple']\n\nclass GameCanvas {\n    constructor(canvasElement, snake, board, tileSize = 48, debugMode = false) {\n        this.board = board\n        this.snake = snake\n        this.tileSize = tileSize\n        this.debugMode = debugMode\n        \n        this.setupHTMLCanvas(canvasElement)\n        this.setup()\n    }\n\n    setupHTMLCanvas(canvasElement) {\n        if (!(canvasElement instanceof HTMLCanvasElement)) {\n            throw new TypeError(`The HTML5 canvas provided: \"${this.canvasElement}\" must be a HTMLCanvasElement`)\n        }\n\n        this.canvas = canvasElement\n        this.context = this.canvas.getContext('2d');        \n    }\n\n    setup() {\n        this.clear()\n        this.setCanvasDimensions()\n        this.setRandomCurrentFood()\n    }\n\n    draw() {\n        this.drawTiles()\n        this.drawCurrentFood()\n        this.drawSnake()\n    }\n\n    drawSnake() {\n        const snake = this.snake\n\n        snake.bodySegments.forEach((segment, _index) => {\n            this.drawObjectAtTile(segment)\n        })\n    }\n\n    drawObjectAtTile(object) {\n        const boardX = object.positionX * this.tileSize\n        const boardY = object.positionY * this.tileSize\n\n        this.context.fillStyle = object.color\n        \n        this.context.fillRect(boardX, boardY, this.tileSize, this.tileSize)\n\n        if (this.debugMode && object.text) {\n            this.context.fillStyle = object.textColor || 'white'\n            this.context.fillText(object.text, boardX, boardY + this.tileSize/2)\n        }\n    }\n\n    drawCurrentFood() {\n        this.drawObjectAtTile(this.currentFood)\n    }\n\n    drawTiles() {\n        for (let rowIndex = 0; rowIndex <= this.board.maxRows; rowIndex++) {\n            for (let lineIndex = 0; lineIndex <= this.board.maxLines; lineIndex++) {\n                const color = this.debugMode ? ((lineIndex + rowIndex) % 2 == 0 ? 'red' : 'green') : TILE_BACKGROUND_COLOR\n\n                this.drawTile(rowIndex, lineIndex, color)\n            }\n        }\n    }\n\n    drawTile(row, column, color) {\n        const y = row * this.tileSize\n        const x = column * this.tileSize\n        const tileText = ((column + row) + row) - 2 // We remove 2 so the index starts at `0` \n       \n        this.context.fillStyle = color\n        this.context.fillRect(x, y, this.tileSize, this.tileSize)\n        this.context.fillText(tileText , x + this.tileSize / 2, y - this.tileSize / 2)\n    }\n\n    clear() {\n        this.context.clearRect(0, 0, this.canvas.width , this.canvas.width)\n    }\n\n    setCanvasDimensions() {\n        this.canvas.width = this.tileSize * this.board.maxRows \n        this.canvas.height = this.tileSize * this.board.maxRows \n    }\n\n    setRandomCurrentFood() {\n        // Get all tiles where one SnakeFragment already exists, eg: [[0,0], [1,2]]\n        const invalidPositions = this.snake.bodySegments.map((segment) => (segment.positionsArray))\n\n        // If there were already one food in the board, do not allow the new food to appear in the same position\n        if(this.currentFood) { invalidPositions.push(this.currentFood.positionsArray) }\n\n        const positions = this.randomPositionsWithNoObstructions(invalidPositions, this.board.maxLines, this.board.maxRows)\n\n        const foodColor = RANDOM_FOOD_COLORS[Math.floor([Math.random() * RANDOM_FOOD_COLORS.length])]\n        const text = `Food #${this.snake.length}`\n\n        this.currentFood = this.createFood(positions[0], positions[1], (this.debugMode == true? 'white' : foodColor), text)\n    }\n\n    createFood(positionX, positionY, color,  text = '') {\n        return new Food(positionX, positionY, color, text)\n    }\n\n    randomPositionsWithNoObstructions(invalidPositions, maxLines, maxRows) {\n        do {\n            var positionX = Math.floor((Math.random() * maxLines))\n            var positionY = Math.floor((Math.random() * maxRows))\n        } while (invalidPositions.includes([positionX, positionY]))\n\n        return [positionX, positionY]\n    }\n}\n\nmodule.exports = GameCanvas",
    "class Food {\n    constructor(positionX, positionY, color = 'green', text = '') {\n        this.positionX = positionX\n        this.positionY = positionY\n        this.color = color\n        this.text = text\n        this.textColor = 'black'\n    }\n    \n    get positions() {\n        return { x: this.positionX, y: this.positionY }\n    }\n\n    get positionsArray() {\n        return [this.positionX, this.positionY] \n    }\n}\n\nmodule.exports = Food",
    "const Board = require('./board')\nconst GameCanvas = require('./canvas')\nconst Snake = require('./snake')\n\nconst INPUT_MAPPING = {\n    'up':    ['KeyW', 'ArrowUp'],\n    'left':  ['KeyA', 'ArrowLeft'],\n    'right': ['KeyD', 'ArrowRight'],\n    'down':  ['KeyS', 'ArrowDown'],\n}\n\nconst DIRECTIONS = Object.keys(INPUT_MAPPING)\n\nclass Game {\n    constructor(canvasElement, rows = 12, lines = 12, tileSize = 48, debugMode = false) {\n        this.canvasElement = canvasElement\n        this.updateInterval = 100\n        this.rows = rows\n        this.lines = lines\n        this.tileSize = tileSize\n        this.debugMode = debugMode\n        this.redraw = false\n        this.canMoveSnake = true\n\n        this.setup()\n    }\n\n    resetCanvas() {\n        const canvas = document.querySelector(this.canvasElement)\n        const wrapper = canvas.parentElement\n\n    if(wrapper) {\n            wrapper.style.width = `${canvas.width}px`\n            wrapper.style.height = `${canvas.height}px`\n            wrapper.style.margin = '0 auto'\n        }\n\n        this.canvas = new GameCanvas(canvas, this.snake, this.board, this.tileSize, this.debugMode)\n    }\n\n    setup() {\n        this.board = new Board(this.rows, this.lines)\n        this.snake = new Snake(this.board)\n        this.snake.currentDirection = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)]\n\n        this.resetCanvas()\n        this.inputSetup()\n        this.draw()\n    }\n\n    init() {\n        this.setup()\n\n        setInterval(this.update.bind(this), this.updateInterval)\n    }\n\n    draw() {\n        this.canvas.draw()\n    }\n\n    autoMoveSnake() {\n        this.moveSnake(this.snake.currentDirection)\n    }\n\n    update() {\n        this.autoMoveSnake()\n\n        if(this.redraw) {\n            this.draw()\n            this.redraw = false\n        }\n    }\n\n    moveSnake(direction) {\n        // Snake is already moving or animating\n        if(!this.canMoveSnake) return\n\n        this.canMoveSnake = false\n        this.redraw = true\n\n        if (this.snake.moveToDirection(direction)) {\n            this.detectBodySegmentColision()\n            this.detectFoodColision()\n        }\n\n        this.canMoveSnake = true\n    }\n\n    detectBodySegmentColision() {\n        const { snake } = this\n\n        snake.bodySegments.forEach((segment) => {\n            if (!segment.isHead && snake.head.samePositions(segment)) {\n                this.gameOver()\n            }\n        })\n    }\n\n    gameOver(reload = true) {\n        console.log('%c You just lose', 'color: red; font-weight: bold; background: black; padding: 10px;');\n\n        this.setup()\n    }\n\n    detectFoodColision() {\n        const { snake, currentFood } = this.canvas\n\n        if (snake.head.samePositions(currentFood)) {\n            snake.eatFood(currentFood)\n\n            this.spawnRandomFood()\n            this.draw()\n        } \n    }\n\n    spawnRandomFood() {\n        this.canvas.setRandomCurrentFood()\n    }\n\n    inputSetup() {\n        document.addEventListener('keyup', (event) => {\n            // Don't allow to move when is the Snake is already moving\n            if(this.redraw == true) return \n\n            const keyData = this.detectKeyFromCode(event.code)\n\n            if(keyData.direction) {\n                this.moveSnake(keyData.direction)\n                this.redraw = true\n            }\n        })\n    }\n\n    detectKeyFromCode(keyCode, inputKeys = INPUT_MAPPING) {\n        var keyData = { direction: null , key: null }\n\n        Object.keys(inputKeys).forEach((keyList) => {\n            if(inputKeys[keyList].includes(keyCode) && keyData.direction == null) {\n                keyData = { direction: keyList, key: keyCode }\n            }\n        })\n\n        return keyData\n    }   \n}\n\nmodule.exports = Game",
    "const NOT_ALLOWED_DIRECTIONS_TO_TURN = {\n    'up': ['down'],\n    'down': ['up'],\n    'left': ['right'],\n    'right': ['left']\n}\n\nconst SnakeSegment = require('./snake_segment')\n\nclass Snake {\n    constructor(board) {\n        this.board = board\n        this.currentDirection = this.lastDirection = null\n        this.foods = []\n        this.bodySegments = [\n            new SnakeSegment(0, 0, 'head')\n        ]\n    }\n\n    get length() {\n        return this.bodySegments.length\n    }\n\n    get head() {\n        // The head is always the last segment\n        return this.bodySegments[this.bodySegments.length - 1]\n    }\n\n    get positionX() {\n        return this.head.positionX\n    }\n\n    get positionY() {\n        return this.head.positionX\n    }\n\n    get headPositions() {\n        return this.head.positions\n    }\n\n    eatFood(food) {\n        if(typeof(food) != 'object') {\n            throw TypeError('Invalid food')\n        }\n\n        const segment = this.createSegment(this.bodySegments[0], `Segment #${this.bodySegments.length}`)\n\n        this.foods.push(food)\n        this.addSegment(segment)\n    }\n\n    createSegment(reference, text = '', type = 'segment', color = 'black') {\n        const positions = this.calculateSegmentPositionFromReference(reference, this.lastDirection)\n\n        return new SnakeSegment(this.calculateX(positions.x, this.board.maxLines), this.calculateY(positions.y, this.board.maxRows), type, color, text)\n    }\n\n    calculateSegmentPositionFromReference(reference, lastDirection) {\n        let positionX = this.calculatePositionFromDirection(reference.positionX, lastDirection, { 'left': 1, 'right': -1 })\n        let positionY = this.calculatePositionFromDirection(reference.positionY, lastDirection, { 'up': 1  , 'down':  -1 })\n        \n        return { x: positionX, y: positionY }\n    }\n\n    calculatePositionFromDirection(position, lastDirection, factors = {}) {\n        return position + (factors[lastDirection] || 0)\n    }\n        \n\n    segmentExists(segment) {\n        return this.bodySegments.some((snakeSegment) => (\n            snakeSegment.samePositions(segment)\n        ))\n    }\n\n    addSegment(segment) {\n        //if (this.segmentExists(segment)) {\n        //    throw Error('One segment already exists in this position')\n        //}\n\n        // Append a new part to the beginning of the segments\n        this.bodySegments.unshift(segment)\n\n        return this.bodySegments\n    }\n\n    canTurnTowardsDirection(currentDirection, desiredDirection) {\n        if(this.length == 1) return true\n\n        return !NOT_ALLOWED_DIRECTIONS_TO_TURN[currentDirection].includes(desiredDirection)\n    }\n\n    moveToDirection(direction) {\n        if (!this.canTurnTowardsDirection(this.currentDirection, direction)) return false\n\n        switch (direction) {\n            case 'up':\n                this.moveUp()\n                break\n            case 'left':\n                this.moveLeft()\n                break\n            case 'right':\n                this.moveRight()\n                break\n            case 'down':\n                this.moveDown()\n                break\n        }\n\n        // Move with success\n        return true\n    }\n\n    moveLeft() {\n        this.move(this.head.positionX - 1, this.head.positionY, 'left')\n    }\n\n    moveRight() {\n        this.move(this.head.positionX + 1, this.head.positionY, 'right')\n    }\n\n    moveUp() {\n        this.move(this.head.positionX, this.head.positionY - 1, 'up')\n    }\n\n    moveDown() {\n        this.move(this.head.positionX, this.head.positionY + 1, 'down')\n    }\n\n    moveSegment(segment, x, y, direction) {\n        segment.lastPositionX = segment.positionX\n        segment.lastPositionY = segment.positionY\n        segment.positionX = x\n        segment.positionY = y\n\n        return segment\n    }\n\n    moveHead(x, y, direction) {\n        const nextX = this.calculateX(x, this.board.maxLines)\n        const nextY = this.calculateY(y, this.board.maxRows)\n\n        return this.moveSegment(this.head, nextX, nextY, direction)\n    }\n\n    moveBodySegmentsTowardsHead(direction) {\n        // Clone the original array\n        const segments = this.bodySegments.slice(0).reverse()\n\n        segments.forEach((segment, index) => {\n            // We already moved the head, so we need to skip it and just move the body segments\n            if(!segment.isHead) {\n                const targetSegment = segments[index - 1]\n\n                this.moveSegment(segment, targetSegment.lastPositionX, targetSegment.lastPositionY, direction)\n            }\n        })\n    }\n\n    move(x, y, direction) {\n        this.lastDirection = this.currentDirection\n        this.currentDirection = direction\n\n        this.moveHead(x, y, direction)\n        this.moveBodySegmentsTowardsHead(direction)\n    }\n\n    calculateX(positionX, maxPosition) {\n        return this.calculateValidPosition(positionX, maxPosition)\n    }\n\n    calculateY(positionY, maxPosition) {\n        return this.calculateValidPosition(positionY, maxPosition)\n    }\n\n    calculateValidPosition(position, maxPosition, minPosition = 0) {\n        let newPosition = position\n\n        if (position < minPosition) {\n            newPosition = maxPosition\n        } else if (position >= maxPosition) {\n            newPosition = minPosition\n        }\n\n        return newPosition\n    }\n}\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n    module.exports = Snake\nelse\n    window.Snake = Snake",
    "const VALID_SEGMENTS_TYPES = ['head', 'segment']\nconst validPosition = (position) => (\n    typeof(position) === 'number' && position >= 0\n)\n\n\nclass SnakeSegment {\n    constructor(positionX, positionY, type, color = 'black', textColor = 'white') {\n        this.positionX = this.lastPositionX = parseInt(positionX)\n        this.positionY = this.lastPositionY = parseInt(positionY)\n        this.type = type\n        this.text = type\n        this.color = color\n        this.textColor = textColor\n\n        this.validate()\n    }\n\n    get isHead() {\n        return this.type == 'head'\n    }\n    \n    get positions() {\n        return { x: this.positionX, y: this.positionY }\n    }\n\n    get positionsArray() {\n        return [this.positionX, this.positionY] \n    }\n\n    samePositions(anotherSegment) {\n        return (this.positionX === anotherSegment.positionX && this.positionY === anotherSegment.positionY)\n    }\n\n    validate() {\n        if(!VALID_SEGMENTS_TYPES.includes(this.type)) {\n            throw TypeError(`The provided type: '${this.type}' is not valid as a SnakeSegment`)\n        }\n\n        if(!validPosition(this.positionX)) {\n            throw TypeError('The parameter `positionX` must be a positive integer number')\n        }\n\n        if(!validPosition(this.positionY)) {\n            throw TypeError('The parameter `positionY` must be a positive integer number')\n        }\n    }\n}\n\nmodule.exports = SnakeSegment"
  ]
}